后端技术栈：SpringBoot，Springcloud，TkMybatis，SpringDataJPA，shiro，redis，mysql，elasticSearch，nginx，rabbitmq

用户注册：
一：用户输入手机号获取验证码
二：请求达到后端，先查询该手机号是否被注册过
三：随机生成一个验证码，手机号作为key，验证码作为value存入redis
四：发送一条MQ
五：短信发送方接收到消息，根据手机和验证码，通过阿里云向该手机号发送验证码
六：用户填写好信息及验证码，请求发送到后端
七：根据用户的手机号到redis中查询验证码并校验，校验通过，保存用户信息

用户登录：
一：用户输入手机号和密码
二：根据手机号查询用户的信息
三：校验用户密码和输入的密码是否相同
四：密码相同生成jwt令牌，将jwt令牌存入cookie当中

商品的分类和品牌和参数组
商品的分类，分为三级，树形结构，一级分类的parentid为0
分类和品牌的关系是多对多
分类和品牌对商品的关系都是一对多
分类和参数组的关系时一对多，参数组和参数值的关系时一对多

Spu Sku 
Spu和Sku是一对多
Spu指的是商品的总名称，Sku是该Spu下的细化商品（eg：Spu：小米8 Sku：小米8 64G，小米8 32G）
Spu对应的分类下有对应的参数值，参数值中有公用和私有的，对于某一Spu对应的多个Sku公用的是相同的，他们的区别就是私有的参数不同，在Spu_detail表中special_spec字段指定好私有参数
在生成Sku时就为每个Sku指定好不同的私有参数，Sku表的indexs字段：它是一个下标，对应着Spu_detail表中special_spec字段中的数据 own_spec字段保存着index下标对应的名称
				           eg（special_spec:{"4":["白色","金色","玫瑰金"],"12":["3GB"],"13":["16GB"]},indexs:{0,0,0} own_spec:{白色，3GB，16GB}）

rabbitmq的使用：
用户新增一个商品：发送MQ Search微服务接收，根据商品信息插入到elasticSearch中
用户修改一个商品：发送MQ Search微服务接收，Goods微服务接收  根据商品信息插入到elasticSearch中（覆盖之前的），删除掉对应的静态化页面
用户删除一个商品：发送MQ Search微服务接收，Goods微服务接收  根据商品信息删除掉之前elasticSearch中的商品数据，删除掉对应的静态化页面

用户第一次在前端点击商品详情，则为其生成静态化页面保存到nginx的html目录下，用户下次再点击的话就在nginx层直接返回数据了

前端的搜索：
elasticSearch实现
第一次搜素根据关键字进行搜索，并将结果进行聚合，根据商品分类，商品品牌和各个参数信息进行聚合
第二次搜索时，根据关键字和第一次搜索聚合形成的条件（商品分类，商品品牌和各个参数信息）进行搜索，也将结果进行聚合

购物车：
分两种状态：登录状态下和未登录状态下
未登录状态下：将购物车信息存储到页面的local storage当中
登录状态下：将未登录时local storage中存放的商品信息进行合并，购物车信息存放到redis的Hash当中（总Key：用户Id，key：商品Id，Value：商品的具体信息）

微信支付：
引入微信支付的接口
一：根据订单Id，支付金额，调用微信接口生成支付URL，返回给前端
二：前端根据URL生成二维码
三：用户扫描二维码进行支付
四：前端定时查询后端，后端调用微信接口根据订单Id查看是否支付成功，支付成功则更改订单状态

下单：
一：用户添加商品到购物车，点击下单
二：对参数做校验，查看库存是否足够
采用分布式事务
三：生成预订单
四：RPC远程调用，扣减库存，扣减优惠券~
五：将订单设为可见状态
六：用户支付订单，调用支付的接口
七：前端定时扫描查看是否支付成功，支付成功修改订单状态