volatile
轻量级的同步机制
由于现在计算机的不断发展，CPU的速度比内存快了很多，因此在CPU和内存之间引入了工作内存，CPU通过工作内存来和主内存做交互，在多线程环境下就牵扯到了数据不一致 （可见性）的问题
一：保证了可见性：当一个线程对添加了volatile的变量进行修改后，线程write值到主内存后触发mesi缓存一致性协议（基于CPU嗅探机制实现），发出一条数据改变的总线，此时其他线程就可以监听到
那么就将当前工作内存中的值失效掉，重新到主内存中load最新的值。
二：不保证原子性：当多个线程执行i++操作时不保证原子性，这就要说到JMM（JAVA内存模型）了，因为cpu和内存读取速度的相差很多，于是在cpu中新增了一个工作内存，先把主内存中的值读取到工作内存再
进行操作，JMM的操作分为read：读取主内存的值，load将值存放到工作内存，use使用工作内存的值，assign修改工作内存的值，store将工作内存的值存入主内存，write将工作内存的值赋值给主内存，lock加
锁，unlocak解锁，eg：2个线程同时执行i++，他俩都做到了assign操作，此时其中一个线程执行了store操作，由于mesi协议和Cpu嗅探机制，另外一个线程立即从主内存中读取到了新值2，并执行store操作，此时
主内存中的值为2，但执行了两次i++操作值应为3
三：禁止指令重排:通过内存屏障来禁止指令重排
指令重排：jvm会打乱我们编写好的代码的顺序的执行，以此来提高效率（单线程环境下指令重排不影响结果，多线程环境下指令重排会影响结果）
内存屏障：是一种cpu指令，用于控制特定情况下的重排序（相当于在多条指令之间加了堵墙不允许指令重排），jvm也会根据内存屏障来禁止指令重排
eg：在单例模式中，new一个对象的操作，可以细分为第一步在堆中开辟一个空间，为该空间的值初始化，将该空间赋值给变量。但JAVA底层会进行指令重排，先赋值再初始化，此时别的线程进来，正好执行到
第二步还没有初始化完成，但他一做判断发现不为null，直接获取对象做操作，由于没初始化会发生空指针异常。此时应加入volatile关键字禁止指令重排的发生。

cas
轻量级的同步机制
比较再交换，保证了原子性
有一个预期值和修改值，当主存中的值和预期值相同时，则可以完成修改操作。（如果预期值和内存中的值不相同，则会去主内存中获取最新的值）
预期值A 修改值B 主存值C 先用A和C比较，A和C相同则将主存值C改为B
cas如何确保原子性：cas是一条cpu并发原语。 cas底层是由unsafe类（包含了很多的native对象）和自旋锁实现的
cas的具体实现类：juc包下的原子类：atomicInteger atomicReference
cas的问题ABA问题：当A准备修改前，B已经修改过了，且又将值给还原了回来，此时A可以修改成功，但这中间是存在问题的，因为他不知道B修改过了
		解决：新增版本的方式，在每次修改时都校验版本，atomicStampedReference可以解决该问题

cas是用来保证原子性的，那么cas底层是如何保证原子性的？
所谓底层保证原子性：cas的操作不是一步完成的，它需要先比较内存和预期值是否相同，然后再修改内存值
那么怎么保证：比较然后交换这两步操作的原子性呢？拿java中cas的具体实现atomic举例，它在底层调用了unsafe类，这个unsafe类是一个native类即它是通过C/C++来编写的，那么在C++底层是通过
调用lock cmpxchg(compare and exchange)指令来保证这两步操作的原子性的。
      (汇编指令，直接将总线锁定，只允许当前核来操作，其他核无法操作直至当前核操作完毕释放lock)

阿里巴巴开发手册提到用LongAdder对象比AtomicLong性能更好，原因？
在多线程环境下，用AtomicLong时，某一时刻内只有一个线程是执行成功的，其它线程将执行失败进入自旋状态(不断重试)，自旋就会成为瓶颈
LongAdder的思想就是把要操作的目标资源分散到cell数组中，大大降低了失败的次数，比AtomicLong性能好
				（和concurrentHashMap一样采用了分段锁的思想）

当程序需要同步时，什么时候用cas，什么时候用synchroniezd？
cas底层就是自旋操作，不停地尝试修改值来获取到锁，而synchronized的话就是直接加锁，获取不到就阻塞
所以当业务流程执行速度快且并发小的时候用cas，业务流程执行慢或并发高的时候用synchronized
				       （因为自旋操作十分消耗cpu的资源）