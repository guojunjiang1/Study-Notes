volatile
轻量级的同步机制
由于现在计算机的不断发展，CPU的速度比内存快了很多，因此在CPU和内存之间引入了工作内存，CPU通过工作内存来和主内存做交互，在多线程环境下就牵扯到了数据不一致 （可见性）的问题
一：保证了可见性：当一个线程对添加了volatile的变量进行修改后，线程write值到主内存后触发mesi缓存一致性协议（基于CPU嗅探机制实现），发出一条数据改变的总线，此时其他线程就可以监听到
那么就将当前工作内存中的值失效掉，重新到主内存中load最新的值。
二：不保证原子性：当多个线程执行i++操作时不保证原子性，这就要说到JMM（JAVA内存模型）了，因为cpu和内存读取速度的相差很多，于是在cpu中新增了一个工作内存，先把主内存中的值读取到工作内存再
进行操作，JMM的操作分为read：读取主内存的值，load将值存放到工作内存，use使用工作内存的值，assign修改工作内存的值，store将工作内存的值存入主内存，write将工作内存的值赋值给主内存，lock加
锁，unlocak解锁，eg：2个线程同时执行i++，他俩都做到了assign操作，此时其中一个线程执行了store操作，由于mesi协议和Cpu嗅探机制，另外一个线程立即从主内存中读取到了新值2，并执行store操作，此时
主内存中的值为2，但执行了两次i++操作值应为3
三：禁止指令重排:通过内存屏障来禁止指令重排
内存屏障：是一种cpu指令，用于控制特定情况下的重排序，jvm也会根据内存屏障来禁止指令重排
eg：在单例模式中，new一个对象的操作，可以细分为第一步在堆中开辟一个空间，为该空间的值初始化，将该空间赋值给变量。但JAVA底层会进行指令重排，先赋值再初始化，此时别的线程进来，正好执行到
第二步还没有初始化完成，但他一做判断发现不为null，直接获取对象做操作，由于没初始化会发生空指针异常。此时应加入volatile关键字禁止指令重排的发生。

cas
轻量级的同步机制
比较再交换，保证了原子性
有一个预期值和修改值，当主存中的值和预期值相同时，则可以完成修改操作。（如果预期值和内存中的值不相同，则会去主内存中获取最新的值）
预期值A 修改值B 主存值C 先用A和C比较，A和C相同则将主存值C改为B
cas如何确保原子性：cas是一条cpu并发原语。 cas底层是由unsafe类（包含了很多的native对象）和自旋锁实现的
cas的具体实现类：juc包下的原子类：atomicInteger atomicReference
cas的问题ABA问题：当A准备修改前，B已经修改过了，且又将值给还原了回来，此时A可以修改成功，但这中间是存在问题的，因为他不知道B修改过了
		解决：新增版本的方式，在每次修改时都校验版本，atomicStampedReference可以解决该问题