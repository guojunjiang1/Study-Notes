ThreadLoal为每个线程提供一个私有局部变量
原理：
①：每个Thread对象都对应一个Threadlocals字段，ThreadLocals字段指向了ThreadlocalMap对象。（每个Thread都对应一个ThreadLocalMap）
②：ThreadLocalMap是ThreadLocal的内部类，他没有实现map接口，自己实现了map的功能。
③：这个ThreadLocalMap对象中以ThreadLocal（源码中为this）作为Key,Value是在ThreadLocal中设置的值。
④：ThreadLocal本身并不存值，set的值是存放在ThreadLoclMap当中的，可以通过ThreadLocl来作为key从ThreadLocalMap中获取set的值。

为什么把ThreadLoacl存放到ThreadLocalMap中而不是HashMap中？
一：ThreadLoaclMap的Key可以指定为特殊类型，如ThreadLocal的引用
二：ThreadLocalMap能解决内存泄漏问题，在每次写数据和读数据时都会清除掉已过期的垃圾数据

ThreadLocal的内存泄漏问题：
使用完ThreadLocal后，ThreadLocalMap中对应的Key会被垃圾收集器清除掉，但是当前线程对应的ThreadLocalMap中的Value却会一直存在，直至线程销毁(对应的ThreadLocalMap也会销毁)，但是现在一般
都使用线程池的方式，线程的生命周期就很长，在这个过程中value不被回收就造成了内存泄漏，虽然调用它的set()、get()方法会对key为null的entry进行回收，但如果恰好一直没调用那么就一直在内存泄漏，因此
其实内存泄漏与ThrealocalMap的key是不是弱引用关系不大，主要是使用完没及时调用remove方法清除value导致的。

在调用set()、get()时会清理掉ThreadLoaclMap中已过期（key为null）的entry数据，调用remove() 方法的时候，会清理掉当前ThreadLoacl在ThreadLocalMap中的entry数据 。
使用完ThreadLocal方法后 最好手动调用remove()方法，防止内存泄漏。

ThreadLocal的set方法：获取当前的Thread对象，获取Thread对象的threadLocals字段，threadLocals指向了ThreadLocalMap，若map还没初始化则先对其进行初始化，然后以当前的ThreadLocal引用作为key，
set的值作为value放入ThreadLocalMap中，（ThreadLocalMap中用Entry对象来保存key,value（类似于HashMap的Node对象），然后放到数组当中）
ThreadLocal的get方法：获取当前的Thread对象，获取Thread对象的threadLocals字段，threadLocals指向了ThreadLocalMap，以当前的ThreadLocal作为key，计算出hashcode，然后计算出索引位置，获取
并返回vlaue，如果之前没有调用set直接调用get的话，是获取不到value的，则会去调用initvalValue()方法，根据获取到的返回值(value)和当前的ThreadLocal(key)组成entry，存放到索引所在位置，返回value。
ThreadLocal的initvalValue方法：当前线程没有调用set方法直接调用get方法时会调用initvalValue方法，默认的返回值为null，可以重写该方法修改返回值
ThreadLocal的remove方法：：获取当前的Thread对象，获取Thread对象的threadLocals字段，threadLocals指向了ThreadLocalMap，然后清除掉当前ThreadLocal在ThreadLocalMap中对应的entry

ThreadLocalMap中以ThreadLocal的引用作为Key（它重写了hashcode方法），它采用黄金分割数来分割找到存放位置，黄金分割数可以更均匀的分布到Entry中减少Hash冲突，
发生Hash冲突时采用的是线性探测法来解决（线性探测法：若当前元素有数据，则采用+1寻找下个元素，若找到最后一个还有数据，则从0开始继续找，直到找到元素为空后在该元素进行存储）
(发送hash冲突是因为，我们可能一个线程可能设有多个ThreadLocal对象，这多个ThreadLoacl对象就存放在了当前线程对应的ThreadLocalMap当中)

为什么ThreadLocalMap的key是弱引用？
为了方便在使用完ThreadLocal后将key给回收掉避免造成内存泄漏，但这也无法解决value的内存泄漏，因此需要使用完后调用remove方法

每个线程想拥有多个全局变量怎么办？
可以创建多个ThreadLocal来实现，每个ThreadLocal存放一个全局变量

为什么建议ThreadLocal定义为static类型？
因为是由ThreadLocalMap来存放set的数据的，而并非ThreadLocal对象，只需要让ThreadLocal初始化一次就够了，没必要每次调用都初始化，所以定义为static类型

ThreadLocal使用场景：一个类中需要使用到全局变量，在不加锁的场景下，可以使用ThreadLocal来存放这个全局变量

ThreadLocal在Spring中的使用场景：(Spring事务）
事务的作用就是保证一组操作要么同时成功要么同时失败，有个前提条件是一个事务内的所有操作都是在同一个数据库连接上（但连接不是线程安全的，多线程环境下事务会出问题）。
在Spring中，为了保证事务的原子性，它采用了ThreadLocal这个数据结构，ThreadLocal保存的类型是一个Map（Key是DataSource数据源，Value是Connection连接），为了应对多数据源的场景所以用map
来保存数据源-连接的关系，也就是说每一个线程都对应了一个map，用了ThreadLocal可以保证每个线程的事务内所有操作都获取同一个Connection连接，也就保证了事务的原子性了。
（线程threadLocal.get()，得到Map，根据数据源获取到同一个Connection连接）

ThreadLocal的子类InheritableThreadLocal
InheritableThreadLocal支持父子线程间共享数据，也就是说在父线程中用InheritableThreadLocal来保存数据，子线程也可以get到数据。
如果是ThreadLocal的话，子线程是get不到数据的。