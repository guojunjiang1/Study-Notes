面试官你好，我叫郭峻江，我现在是计算机科学与技术系的
大四学生，我对JAVA开发有着很浓厚的兴趣，
对目前一些主流的开源框架有所了解，比如spring springmvc mybatis springdatajpa之类，
也对现在流行的微服务框架有所了解如springboot，springcloud，
自己也动手做了两个基于微服务架构的项目了，一个是视频学习的平台还有一个是电商项目，
在这过程中也涉及到了一些高并发，分布式场景，
也对优化高并发的方案有所了解（搭建集群然后通过nginx负载均衡，redis提前做缓存，mq来削峰填谷，异步处理数据）
也了解了在分布式场景下的分布式事务和分布式锁
在此期间对自己的提升非常大。面试官我介绍完了

http://www.biyezuopin.cc/default.asp
https://www.wondercv.com/：写简历的
限流：
漏桶算法
请求先进入到漏桶里,漏桶以一定的速度处理清理,当请求个数过大会直接溢出，访问频率超过接口响应速率
然后就拒绝请求
2.2 令牌桶算法
令牌桶算法(Token Bucket)和 漏筒效果一样但方向相反的算法
Google开源工具包Guava提供了限流工具类RateLimiter,该类基于令牌桶算法(Token Bucket)来完成限流,

IOCBean的加载过程：
①：首先加载配置文件（可以是xml或者是java配置类），Spring使用BeanDefinitionReader去处理这些配置信息，
xml的话有一个XmlBeanDefinitionReader去处理
②：读取完配置文件后，通过BeanDefintionParser获取Class路径，封装成BeanDefinition后就放入
beanDefinltionMap中（也是个hashmap，专门用来存放bean信息的，Key为beanid，value为class路径）
③：对bean做初始化：通过DefaultListableBeanFactory的getBean()方法去初始化，
实际由AbstractAutowireCapableBeanFactory的doCreateBean（）去完成。

一致性Hash算法也是使用取模的方法，而一致性Hash算法是对2^32取模，一致性Hash算法将整个哈希值空间
组织成一个虚拟的圆环

zset的底层是用跳表（一个多层的有序链表，一种基于概率统计的插入算法）实现
>:redis中的zset为什么不使用红黑树而使用跳跃表？
①：首先，在做范围查询的时候，平衡树的操作要比跳跃表复杂。因为平衡树，在查询到最小值的时候，
还需要采用中序遍历去查询最大值。 而跳表只需要在找到最小值后，对第一层的链表（也就是最底层的链表）
进行若干次遍历即可。
②：平衡树的删除和插入，需要对子树进行相应的调整，操作复杂。而跳表只需要修改相邻的节点即可
③：从整体上来看，跳表算法实现的难度要低于平衡树
>:查询：查询方法类似于二分查找，所以跳跃表的查找的时间复杂度为O(logN)
   跳跃表每个节点包含两个指针，一个指向同一链表中的下一个元素（next），一个指向下面一层的元素
>插入:我们往跳表中插入数据的时候，可以选择同时将这个数据插入到第几层中，比如随机函数生成了值 K，
   那我们就将这个结点添加到第一层到第 K 层这 K 级索引中。
随机的K是如何产生的：
通过随机数来产生，第一层肯定需要添加元素，所以K的初始值为1。后面的，如果随机数为1，就是K加一，
随机数为0，就退出。这样每一层插入该元素的概率为（1/2）^ n。
这样就很大程度上保证了后一层元素的总数量是前一层元素的2倍。
>删除:在各个层中找到包含 x 的节点，直接删除元素，然后调整一下删除元素后的指针即可。
跟普通的链表删除操作完全一样。