测量一个算法好坏的方式：时间复杂度、空间复杂度
时间复杂度：一般时间复杂度都是讲的“最差”情况，计算出来后忽略常数项、忽略低数项，获取到最终的结果
空间复杂度：除给定空间外，额外用到的空间

*排序算法：
                时间复杂度          最坏时间复杂度          最好时间复杂度        空间复杂度             稳定性
选择排序：n平方	           n平方                         n平方                      1                            不稳
冒泡排序：n平方                  n平方                         n                             1	                          稳
插入排序：n平方	           n平方                         n                             1                             稳（重要）
希尔排序：n1.3次方             n平方	             n		            1                            不稳
归并排序：nlogn	           nlogn	             nlogn	            n		           稳（重要）
快排排序：nlogn	           n平方	             nlogn	            logn	           不稳（重要）	
计数排序：n+k                    n+k	             n+k	            n+k                        稳(这里的k是指计数数组)
基数排序：nk	           nk                              nk	            n 		           稳
堆排序：   nlogn                  nlogn	             nlogn                      1                            不稳（重要）

java底层，对于存放基本类型的数组排序采用的是双轴快排，对于存放引用类型的数组排序采用的是归并排序

*一般来讲主要看平均时间复杂度就可以了（上面的时间复杂度就是平均时间复杂度）

*稳定性：
当数组中有两个相同的数，在排序后如果他俩的相对位置发生变化就是不稳定的，如果不发生变化就是稳定的
（eg：有数组【2,2,1】，当使用选择排序过后，一开始索引为0的2会跑到索引为1的2的后面，他俩相对位置发生了变化，所以选择排序就是不稳定的）

*结果测试（对数器）：
所谓对数器就是验证算法是否正确，可先通过肉眼观察、然后和正确用例作比较、最后产生足够多的样本后与正确的算法结果做比较

①：选择排序
核心思想：每次循环挑选出一个哨兵值，和后面的数依次进行比较，最终将这些数中最小的数和哨兵交换位置

②：冒泡排序
核心思想：从头开始遍历每个数和后面的数进行比较，大了就交换位置，每次把最大的数放到末尾，共循环n次

③：插入排序
核心思想：从索引为0的数开始依次插入到前面的数中，按从小到大的顺序排列

④：希尔排序
核心思想：插入排序的升级版，每次循环指定一个步长，在数组中按照步长来找出元素做交换，直到循环到步长为1则全部排好序，在对元素排序时使用
	插入排序。（相比插入效率高一些，步长越长需要交换的元素越少，步长越短交换元素时移动的位置越少）
	 
⑤：归并排序
核心思想：采用分支递归+合并，二分法来排序思想，将一个完整的数组一直拆分，拆分成2 2 2 2的组合后再将它们两两合并起来

⑥：快速排序
核心思想：找一个哨兵值，比它小的放到它的左边，比它大的放到它的右边，然后递归它的左边排序，递归它的右边排序

⑦：计数排序
核心思想：创建一个计数数组，遍历原数组，每遍历到一个数将计数数组中数对应下标的元素+1，最后根据计数数组中的值创建新数组并一个个赋值
（适用于数据量大但是数据范围小的场景，eg：2万名员工的年龄排序/50万名高考生的成绩排序）

⑧：基数排序
核心思想：根据最大值的位数来确定循环次数，先对个位数进行比较排序，然后对十位数进行比较排序......直到最高位比较排序完，得到最终结果
（每次循环都用一个二维数组的桶来记录位数是多少）


*树
二叉树：树的任一结点最多包含两颗子树
满二叉树：除叶子结点外每个结点都有两个子结点，且叶子结点都在同一层（一棵树共有2的k次方(高度)-1个结点）
二叉搜索树：左小右大，每个结点的左子树都小于当前结点，每个结点的右子树都大于当前结点
平衡二叉树：树中任一结点的左右子节点的树高之差不超过1
红黑树：结点不是红色就是黑色（HashMap底层）
B+树：多插树，且各个节点存放很多数据（MySql索引底层）


*并查集
定义：在有一个N个元素的集合问题中，我们初始让每个元素都属于一个独立的集合，然后按照顺序将集合合并，期间要反复查找一个元素在哪个集合
中。
一般写并查集题目，需要提供两个方法：V find(V x)：查询x所在集合的根元素
			            void union(V x,V y)：把X，Y各自所在的集合合并为一个集合