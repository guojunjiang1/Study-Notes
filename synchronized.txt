Synchroniezd是保证在并发情况线程安全，保证了可见性，原子性，禁止指令重排。
线程安全：指多个线程同时对一共享数据进行操作，所导致出现的错误，eg：3个线程同时执行i++会导致值的覆盖
保证可见性：添加了Synchronized后，线程在获取锁后，都要清空工作内存的值，重新到主内存中获取最新的值，保证了可见性。
保证原子性：添加了Synchronized后，因为锁是互斥的，所以同一时间只能有一个线程获取到锁，这就保证了原子性。
可重入性：Synchronized中有一个recursions计数器，可以记录获取锁的次数。
不可中断性：当线程想获取锁时，锁被其他线程占用，此时该线程处于阻塞等待状态，在该阻塞等待状态下不能被中断。

Synchronized的底层原理（重量级锁）：
一：同步代码快：在反汇编的底层，Synchronized在执行之前会先执行一个MonitorEnter，先去找同步代码块中的锁对象所对应的Monitor对象（一个C++对象，真正的锁对象），如果Monitor不存在，则JVM会
自动创建一个Monitor。
Monitor当中有四个重要的成员变量，owner：记录拥有锁的线程，recursions：记录线程获取锁的次数（初始为0，每可重入一个锁，就加1），waitset:阻塞队列存放处于阻塞状态的线程（当线程调用了wait方法后
，它会把当前线程封装成一个waiter节点存放到队列中），entrylist：存放处于等待状态的线程（获取不到锁的线程）。
在执行完同步代码块后，会执行一个MonitorExit：它会将monitor对象中的recursions的值减一，当recursions为0时，占有锁的线程自动释放锁。
二：同步方法：他在底层增加了ACC_Synchronized修饰，它也会隐式的调用MonitorEnter和MonitorExit来添加锁和释放锁。

Synchronized获取锁的过程：（MonitorEnter）
它在底层获取锁时，会先获取锁对象对应的Monitor对象
①：先判断recursions是否不为0，owner是否为当前线程，如果是那么就认为该次操作为重入锁（之前获取到外层的锁了，又获取内层的锁），执行recursions++
②：若当前Monitor没有被某一线程占用则尝试通过CAS（Unsafe+自旋）将owner字段设为当前线程，并把recursions设为1
③：如果设置owner为当前线程失败，那么线程进入entryList当中，并尝试一定次数的自旋获取锁，如果还是失败则会将当前线程pork阻塞并将其放入entryList当中

Synchronized释放锁的过程：（MointorExit）
①：执行完同步代码块后，recursions会-1，当recursions为0时，释放锁
②：释放完锁后，从entryList中获取结点，通过unpark方法来唤醒处于阻塞状态的线程。

Synchronized（优化前为什么是重量级锁）：
Monitor的底层会大量的调用内核函数，park和unpark，会造成用户态和内核态的大量切换，会消耗大量的资源。（我们所有的程序都是运行在用户态，涉及到内核的操作运行在内核态（I/O操作））

Synchronized的优化（JDK6之后）
Synchronized有多种锁形态，锁的升级过程：无锁->偏向锁->轻量级锁->自旋锁->重量级锁
Synchronized的锁状态存放在锁对象的对象布局的markWord当中，一个对象在内存中的布局分为：
①对象头（markWord，KlassPointer）(当该对象当作锁对象的时候就会存放锁的信息，还会存放GC的信息如分代年龄和hashcode)（KIassPointer为Class对象指针，指向当前对象对应的类，
可以随时知道当前对象是哪个类的实例）
②：实例数据（对象中的各种字段包括父类的字段，其大小由字段的大小决定，比如byte和boolean是1字节，short和char是2字节，int和float是4字节，long和double是8字节，reference是4字节）
③：对齐填充（虚拟机要求对象所占大小必须为8字节的倍数，当不足时需要用对齐填充来补全，起着占位符的作用）

Synchronized锁消除：当设置了锁，当检测到不存在竞争情况后，会将锁消除掉
Synchronized锁粗化：当检测到一串细小的操作都用同一对象来加锁时，会把同步代码快的范围放大（这样这串操作只需在外面加锁一次即可，for循环）

偏向锁：
偏向锁针对于一个线程重复进入同步代码块（重复获取锁）的场景，一旦有多个线程来竞争锁就不适用了。（当对象头的markWord的64位二进制数中表示偏向线程的bit位都是0时就是一个偏向锁）
当一个线程反复的获取锁释放锁会造成大量资源的浪费，因此会引入偏向锁，锁对象在它的对象头markWord中存放获取偏向锁的线程ID，线程来获取锁只需比较线程ID，是否为偏向锁（1）和锁标志位（01）即可。
*偏向锁无法保证互斥，为什么还要引入偏向锁？
因为很多情况下，我们为了保证代码中某一块业务的安全性，可能会引入synchronized锁，但实际上可能程序在运行过程中很少会发生并发情况，从始至终加锁的那块代码都是单线程在运行的不存在线程安全问题，
这时JAVA引入偏向锁可以大大优化我们的性能。
*偏向锁在退出时会释放掉偏向状态码？
是不会释放掉偏向状态的，它会保留偏向状态，这样该线程下次在获取偏向锁时所需的成本很低，只需要比较一下线程是否相同就可以了。

轻量级锁：（相较于‘monitor’更轻量一些）
轻量级锁针对于多个线程交替的进入同步代码块的场景，一旦有多个线程来竞争锁就不适用了，所以说轻量级锁也是不支持互斥性的。
当多个线程交替的进入锁时使用轻量级锁将提高效率，它加锁的原理是：将锁对象的对象头的MarkWord复制到栈中的LockRecord中且MarkWord更新为指向LockRecord的指针，更新成功则说明加锁成功
轻量级锁并不能代替重量级锁，因为当有多个线程来竞争同一把锁的时候，它的效率是不如重量级锁的，当有多个线程竞争时就将其升级为重量级锁，利用重量级锁的互斥性来保证线程安全。
所谓互斥性就是指：多个线程来竞争同一把锁，可以保证只有一个线程能成功获取到锁其他线程处于阻塞等待状态。

自旋锁：（轻量级到重量级前可引入）
引入自旋锁的原因是，重量级锁在线程获取不到锁被阻塞时，会完成从用户态到内核态的切换，因此会浪费大量的资源，因此可以先不使用重量级锁阻塞，先让其通过自旋的方式尝试获取锁（自旋10次获取不到升级为重量级）
eg：一个人上厕所需要10S，另一个人从座位到厕所需30S，当他到达厕所时发现有人又回到座位（阻塞）这样会浪费很多时间，可以尝试在厕所门口不停的敲门（自旋）
自旋的次数默认是10次，JDK1.6之后引入了自适应自旋锁，它会根据上一次自旋的结果来判断本次自旋的次数（若上一次很多次才自旋成功获取到锁，那么本次则直接让其升级为重量级锁不再自旋，上一次很快获取
到锁，本次则也通过自旋的方式来获取）

重量级锁：Monitor
他的所有操作大量涉及到内核的操作，调用unsafe类的park和unpark方法（阻塞和唤醒线程）时会完成用户态到内核态的转换从而浪费大量资源。

什么情况下锁会膨胀成重量级锁？
①：当在偏向锁和轻量级锁情况下，调用对象的hashcode时，由于对象头空间不够，所以需要升级成重量级锁来存放hashcode
②：当调用锁对象的wait方法时会发生锁膨胀，因为调用wait方法会生成管程对象且只有重量级锁有空间存放管程结点
③：当出现多个线程并发竞争锁时也会膨胀成重量级锁

锁降级：
锁降级操作发生在StopTheWorld期间，jvm会判断锁的力度，当发现不存在多个线程竞争锁的情况后，会将锁进行降级

对锁的优化建议：
一：尽量保证在不影响程序的前提下减小同步代码快的范围
二：锁粗化：一系列操作都用同一个对象来加锁，则把锁的范围设的大一点，这样就只需加锁一次即可
三：当大部分操作都是读操作时，则可以使用读写锁

Synchronized对非静态方法加锁：锁的是调用该方法的对象，俗称“对象锁”
Synchronized对静态方法加锁：锁的是该方法所属的类，俗称“类锁”

死锁是指：两个线程互相占有对方想要的资源，产生了死锁
破坏死锁的条件（破坏其中一个就够了）
①：破坏互斥条件 ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。
②：破坏请求与保持条件 ：一次性申请所有的资源。
③：破坏不剥夺条件 ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
④：破坏循环等待条件 ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？
new一个线程后调用它的start()方法会让该线程进入就绪状态，当线程被cpu调度到之后start（）方法会调用run（）方法
	        直接调用run()方法则会把run方法当做一个普通的方法进行调用

多线程的作用：
CPU有单核和多核的，对于单核CPU下的多线程其实是"虚假的多线程"只是切换速度块看起来像是多线程，对于多核CPU下的多线程才是真正的多线程。
多线程能充分发挥出多核CPU的性能来。

线程间怎么通信？通过wait/notify通信

wait和sleep的区别：
wait是Object类下的方法，sleep是Thread下的方法
调用wait进入等待状态需要其他线程notify唤醒，调用sleep进入阻塞状态经过指定时间后自动唤醒
调用wait会释放掉当前占用的锁，调用sleep则不会释放掉当前占用的锁
wait只能在同步代码快/方法中进行调用，sleep可以在任何地方调用




































