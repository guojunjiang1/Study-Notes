秒杀：
①：商家填写秒杀信息
②：管理员审核通过
③：设置一个定时任务，将秒杀表中，商品库存>0,审核通过，在指定时间段内的商品添加到redis（Hash类型）中
④：用户点击秒杀抢购，进入抢购环节（秒杀页面可以实现页面静态化（第一次访问生成静态化页面，保存到girdFS当中，发消息通知nginx所在的机器，下载页面到nginx中，下次请求过来在nginx层返回页面））
⑤：采用异步多线程（@Async实现或者消息队列）的方式进行秒杀抢购（提高程序响应速度，削锋，解耦）
⑥：①：将用户秒杀抢单的信息存入redis队列中，并调用Spring的异步方法（配置方式：配置类配置线程池启动类添加@EnableAsync注解，然后在异步方法上添加@Async("线程池bean名称")注解）
       ②：也可以将用户信息封装起来后发送一条MQ，进行异步发送，然后在消费该消息时可以采用多线程的方式来消费（配置方式：MQ内部配置多线程或配置线程池来让MQ多线程消费）
⑦：在异步方法中，获取redis队列中的抢单信息，进行抢单
	1：对参数做校验：库存>0，且该用户之前没有购买成功过该商品
	2：生成预订单，将其存放到redis当中（当用户抢单成功且支付后填写收货信息再将其存入数据库）
	3：对库存做扣减（当库存为0时，则需要更新mysql对应数据的库存也为0，且在redis中清除该商品记录）
	4：对抢购状态做更新
	5：发送延时消息
⑧：抢单成功，用户填写收货地址并进行支付：前端传递订单号金额，后端调用WX接口生成支付URL，前端再渲染成二维码
前端定时扫描后端接口，后端接口调用微信接口查看是否执行成功，若支付成功，则将redis中的订单数据+地址数据存入到数据库中

优化问题：
一：采用异步的方式进行抢购，用户无法获取抢单是否成功
解决方案：前端定时发出请求查询是否抢单成功，因此我们需要将抢单的状态存入到redis当中（key为userName+GoodsId,Value为状态），在每次执行完关键步骤后，修改状态。

二：如何避免用户重复排队抢购（某一用户只能成功抢购一个商品，不能一直抢购）
解决方案：使用redis的increment（key（username+GoodsId）,value）命令，在抢单逻辑前进行自增操作，他的自增是原子性操作，第一次调用则会初始化为0然后+1，若>1则说明不是第一次排队抢购。
	（它其实也可以看成是一种限流操作，限制每个用户请求一次）

三：如何解决并发超卖
解决方案：>使用分布式锁
	 >可以采用队列的方式，在定时任务添加秒杀商品到redis时，顺便将库存以list的方式存入redis队列，在参数校验时可以取队列，若取出来为空则说明库存不足（redis取队列元素也是原子性操作）

四：如何解决抢购成功不付款问题
①可以启动一个定时任务，根据指定的超时时间，查询（当前时间-超时时间）之前下订单未支付的订单
②在抢购成功生成预订单时发送一条延时消息，接收方在5分钟后接收到消息判断是否支付，若没支付则关闭该订单且补偿库存
延时消息：Rocket自带
	qingcheng_service_Seckill工程下：
	 Rabbit则需要通过过期消息+死信队列来实现，发送方将消息发送到Queue1指定过期时间5分钟，没有人监听Queue1队列那么过会儿该消息过期，就转发到死信队列，建立死信队列Queue2,接收方
	监听Queue2，就可以接受到所谓的延时消息了。
	配置方式：配置一个交换机，配置一个过期队列在其中指定过期后转发到的交换机名及routingKey，配置一个死信队列，两个队列都和交换机通过routingKey建立关系
		 此时向过期队列发消息并指定过期时间，接收方监听死信队列即可
	    
五：URL编码
对秒杀的请求URL进行加盐（MD5之类的摘要算法），将URL动态化，防止黄牛或内部人员提前知道秒杀的地址，从而利用电脑抢多个商品，只有从前端获取URL然后到后台校验完才能通过。
（每次点击秒杀详情页的URL都是不同的）
六：限流
前端限流：用户点击了秒杀按钮后，按钮置灰，过几秒再让他点击
后端限流：可以通过sentinel，hystirx对秒杀接口进行限流，以防请求太多打崩数据库
	 10W个请求，我们放1W个进来就行，对于用户来说秒杀本身就是黑盒操作，所以怎么做用户是无法感知到的。
七：保证高可用，高并发
部署秒杀系统集群，采用nginx做负载均衡，在处理秒杀信息请求时采用异步（多线程异步或消息队列）的方式，用redis做缓存
八：提高效率
可以在nginx中的openresty配置一段lua脚本，请求到达nginx后直接访问redis查看是否有库存，不存在就直接返回
九：恶意请求（有团队预谋的请求）
①：nginx对恶意请求（单个用户访问的次数太多）做拦截
②：请求进来了，可以通过redis的increment判断是否重复排队，如果是直接返回（秒杀用户量大，为了公平起见每个用户仅可以有一个请求在排队）
③：终极方法：风控，公司中有专业的风控团队对用户的操作判断是否是机器操作，如果是则会贴上‘机器’的标签，对于‘机器’标签的请求直接丢弃。

秒杀的优化关键点：
一：将同步操作改成效率更高的异步操作
二：用redis缓存来代替mysql操作
三：对整个系统做限流，以保证机器的可用性
四：对非法请求做拦截
五：对秒杀路径进行动态设置
六：对前端秒杀页面进行静态化操作

redis的引用：商品Hash，订单Hash，抢购信息List队列，抢购状态Hash，库存List队列，防重复排队Hash的increment	
https://github.com/qiurunze123/miaosha