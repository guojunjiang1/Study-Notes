阻塞队列：BlockingQueue
阻塞队列的实现有：ArrayBlockingQueue，LinkedBlockingQueue，SynchronousQueue
何为阻塞队列，当队列满了的时候，想添加进去就会进入阻塞状态
阻塞队列的四组api：add/remove（当队列满时直接报异常），offer/poll（返回一个boolean类型的值），put/take（队列满时进入阻塞状态），offer/poll（等待指定的时长，获取不到则直接退出）
作用：阻塞队列可以解决生产者消费者问题，阻塞队列可以构建线程池，消息中间件也可以用它

高效读写的队列：ConcurrentLinkedQueue（它是非阻塞队列，用CAS非阻塞算法来实现）

并行：某一时间段内，有两个或两个以上的程序在执行
并发：某一时刻内，有两个或两个以上的程序在执行

使用线程池的原因：
①：提高系统的资源利用率，现在的CPU都是多核的，如果是单线程就只会用到一个核心，多线程可以充分利用多核，让之前串行执行的任务变成并行执行	
②：对线程这种重要资源的统一管理
③：提高了响应速度（无需再有创建线程的步骤）
④：提高了线程的利用率，线程执行完任务后，线程会回归线程池当中，同时也避免了销毁线程带来的开销

线程池：ThreadPoolExecutor（当程序需要异步处理业务时，可以配置线程池）
线程池的实现：通过Executors来创建 FixedThreadPool SingleThreadExecutor CacheThreadPool
七大参数：核心线程数，总线程数，阻塞队列，非核心线程数等待时间，单位，采用的线程工厂，拒绝策略
拒绝策略：直接抛出异常，将该任务返回给调用者，替换掉阻塞队列中等待时间最长的任务，直接抛弃不管

submit和execute的区别：submit底层也是使用的execute，submit有返回值,submit会把Runnable和Callable都包装成FatureTask
					       （Runnable是没返回值的，如果封装成submit后返回FuturTask对象然后调用get方法会返回null值）

线程池的执行过程：接收到任务后，分配给核心线程去执行，当核心线程都处于执行状态时，将任务添加到阻塞队列当中，当阻塞队列慢时，启动非核心线程来处理任务，当非核心线程也满了之后，就会启动拒绝策略
非核心线程经过指定的空闲时间后，会将其销毁

线程池的5种状态：
run：运行状态正常接收所有的任务，
shutdown：他会调用shutdown方法，不再接收新的任务，对于运行中或队列中的任务，线程池会至少保留一个线程去执行
stop：他会调用shutdownNow（）方法，不会再接收新的任务，停止掉当前正在执行的任务，也不会执行队列中的任务了	
Tidying状态：所有的任务都终止了，workerCount（有效线程数）为0
terminated：结束状态，线程池彻底结束


如何编写线程池？
①：一般我们都手写线程池，因为cache会创建大量的线程造成程序的oom，fixed和single会造成请求的大量堆积（堆积到了阻塞队列）而造成oom
核心线程数：cpu密集型的话个数建议为cpu核数+1，io密集型建议cpu核数*2（io密集型：涉及到文件操作的就是io密集型，cpu密集型：涉及到各种内存操作）
*：对于一个业务需使用线程池调用多个服务的场景：可以提高核心线程数和最大线程数，不用设置队列去缓冲任务。（追求高并行执行任务，提高响应速度）
*：对于大量任务计算的场景(eg:统计各个商店的各个商品)：需要设置队列去缓冲任务，合理设置线程数不必追求太多（任务量巨大，并不追求特高并行执行任务，应该注重如何利用好已有的资源尽可能提升效率）
②：一个系统中有多个业务都要使用到线程池，最好是为多个业务分别建立不同的线程池，根据不同业务的具体场景来指定具体的参数
多个业务使用同一线程池的实战问题：当前有这么一个业务:扣费业务需要用到线程池，在扣费业务中又有同步业务需要用到线程池，他俩如果用一个线程池
			         线程池的核心线程数是1，队列的容量也是1，扣费业务A包括两个同步业务1,2，同步业务2已经执行完毕
			         若出现：核心线程正在执行父任务（扣费业务）A，队列中存放者子任务（1），此时就出现了死锁
			 	      核心线程已被父任务占据，子任务无法获取到线程资源无法正常执行，父任务等待子任务执行完毕，因此父任务无法释放，子任务也无法获取到资源执行，就发生了死锁
			         解决方案：增加一个新的业务线程池，用来隔离父子任务，现有的线程池只用来处理扣费任务，新的线程池用来处理同步任务。这样就可以彻底避免死锁的情况了。
			         https://club.perfma.com/article/646639

线程池的关闭方法：
shutDown和shutDownNow方法， 调用shutDown方法线程池进入shutdown状态不再接收新的任务但会处理完现在正在执行的任务和队列中的任务。
			      调用shutDownNow方法线程池进入stop状态不再接收新的任务，停止掉当前正在执行的任务，也不会执行队列中的任务了。

临界资源：在某一时刻只能有一个进程访问的共享资源叫做临界资源
临界区：每个进程中访问临界资源的那段代码叫做临界区

如果不是线程安全的，我们可以做什么东西来使我们的程序变得线程安全？
如果是集合，我们可以考虑一下juc包下的集合类。
如果是数值/对象，我们可以考虑一下atomic包下的类或者用ThreadLocal来存储。
如果是涉及到线程的重复利用，我们可以考虑一下是否要用线程池。
如果涉及到对线程的控制（比如一次能使用多少个线程，当前线程触发的条件是否依赖其他线程的结果），我们可以考虑CountDownLatch/Semaphore等等
如果synchronized无法满足你，我们可以考虑lock包下的类

线程和进程的区别：
线程是进程更小的单位，一个进程包括多个线程，线程共享同一进程下的方法区和堆空间，各个线程又有自己的程序计数器，本地方法栈和虚拟机栈，一个进程下的多个线程可能会相互有依赖关系，线程有上下文切换
