设计模式的七大原则：
一：职责单一原则：一个类或一个方法尽量只做一件事
二：接口隔离原则：当继承接口时，有用不到的方法，就把该接口拆分成一个自己所需的方法的接口
三：依赖倒转原则：面向接口编程
四：里氏替换原则：在继承一个类时，尽量不要重写父类的方法
五：开闭原则：在需求有变更时，做到类的提供方可以修改代码，类的使用方不要修改代码
六：迪米特原则：类当中尽量都是真朋友（别的类作为方法的参数，返回值，全局变量），不要出现虚假朋友（把别的类当做局部变量）
七：合成复用原则：类与类之间尽量不要使用继承的关系，可以多使用组合（饿汉式的方式直接new出来）

设计模式：
一：单例模式：有懒加载，饿汉式，枚举，静态内部类的方式创建出一个唯一的对象，懒汉式使用双重检索的机制来确保唯一，防止反射破坏唯
一性的时候，可以在构造函数处也添加一个双重检索机制，防止序列化和克隆破坏单例，可实现serializable接口和clone接口重写clone方法和sin
gleton方法。

二：工厂模式：提供一个类，专门用来根据条件，返回不同的子类对象
	       可以极大解耦，当需求有改变时，在工厂类内部修改就行，调用方无需修改代码。
	       (eg:三个类都需要调用BufferedReader,如果不用工厂模式，发送需求改变则在三个类内部都需要修改BufferedReader
	             如果采用工厂模式，在工厂模式内部新建BufferedReader，三个类调用工厂即可，发生需求改变仅需修改工厂模式内部)	
	
三：代理模式：有静态代理和动态代理，动态代理又分为一个基于JDK的接口Proxy代理模式，一个是基于类的cglib代理模式
	       静态代理和动态代理的区别：静态代理在编译时增强，动态代理在运行时增强
	       两个动态代理的区别：JDK动态代理要求被代理的对象实现过接口，cglib则不需要
			         JDK动态代理，底层通过反射来实现代理
			         cglib动态代理，底层利用ASM框架，通过修改被代理类的字节码，来生成子类实现代理
反射：在运行期间，获取到类的信息(字段，方法)
怎么解决反射影响性能的问题？
反射会影响性能，要解决的话我们可以使用缓存将反射的元数据存储起来，下次使用直接到内存中获取即可。
（因此使用反射可以使用一些高性能的反射框架）

四：适配器模式：当一个类不满足使用条件时，将其转化为另外一个满足条件的类，接口适配器：用一个抽象类实现所有的接口并提供空方法，
让别的类在使用该接口时无需将所有的方法都实现

五：建造者模式：专注于类的建造过程，分为4个模块：产品（一个类的所有属性），抽象建造者（抽象出的方法）
具体的实现类（继承抽象建造者的类）和指挥者（创建一个具体实现类，调用实现类中的方法）

六：装饰者模式：对一个类中的方法进行加强（输入输出流的Buffer就是装饰者模式）

装饰者模式和代理模式的区别：
代理模式强调的是：对对象的访问控制，装饰者模式强调的是：给对象加强功能
装饰者模式一般可以多层嵌套(IO流)，代理模式不可以
装饰者是编译时增强，代理则是在运行时增强

七：原型模式：实现克隆之后，可以克隆出多个一模一样的实例（浅拷贝），克隆出的对象中的基本数据类型直接弄一份新的给新对象，引用类
型的数据只是将引用给了新对象，用序列化＋内存输入输出流实现深拷贝，基本数据类型和引用类型都弄一份新的给新对象