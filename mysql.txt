sql注入：当sql语句绑定有参数输入时，可通过外部更改URL的方式，将sql语句进行更改（union）,这样就可以在未获取正确数据的情况下访问系统，对系统的安全性造成破坏
mybatis如何在插入数据后获取主键值：xml中useGeneratekeys属性设置为true
数据库中间件技术：mycat，当mysql设为集群架构时，项目连接mycat，mycat连接mysql集群，这样项目就感觉只连接一个mysql，而不是mysql集群。
sql执行的步骤：from join on where groupby having select disInct orderby limit
mysql执行sql的流程：客户端(jdbc,navicat)操作mysql->连接器->分析器->优化器->执行器->存储引擎（存储引擎就是一种持久化数据的工具、数据的存储格式）
					     (连接器到执行器都是在mqSql的Server当中的，server是一个进程)

mySql中的索引：B+树（用的多），hash
hash：和hashMap一样，根据索引字段对应的值计算出hash后，存储到数组当中
不使用hash的原因：hash冲突耗费时间，hash也会占用内存，最大的问题还是hash不支持范围查询
B+树：非叶子节点只存放索引值，列数据都在叶子节点按从小到大的顺序存放		     
B+树中每个结点存放的数据就是一个16KB大小的数据页，数据页中包括指向下一节点的指针，索引值及对应的数据，主键值
					      myisam中叶子节点存放索引值及其对应的列数据所在的地址
                                                                                      InnoDB中叶子节点存放索引值及其对应的列数据

使用索引的流程：hash：计算出where条件后，=后，的真实值对应的hash值，然后在数组中定位查找
	          B+树：计算出where条件后，=后，的真实值对应的索引值，在B+树中一层一层的io查找

mysql的索引优化：
索引就是一个用来排序+查找的数据结构，用来减少数据查询时的io次数提高效率，它底层是用B+树实现，一个表中最多可建立16个索引
创建索引的方式：createIndex xxx on tableName（字段1，字段2）
删除索引的方式：dropIndex xxx on tableName
查看索引的方式：show Index from tableName

mysql中的存储引擎（持久化数据的工具、数据的存储格式）：InnoDB MyIsam
InnoDB和MyIsam的区别：
一：InnoDB支持行锁（innodb只有在使用索引时采用行锁，其他情况使用表锁），MyIsam是表锁
二：InnoDB支持事务，MyIsam不支持事务
三：InnoDB支持外键，MyIsam不支持外键
四：InnoDB支持聚集索引，MyIsam不支持
五：InnoDB的数据文件：.frm：表结构，.ibd：索引+数据，MyIsam的数据文件：.frm：表结构，.MYI：索引，.MYD：数据
一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15？
MyIsam的话是18，InnoDB是15

唯一索引：所建立的索引所属列的值必须是唯一的，且可以为null
复合索引：一个索引中包含多个列
单值索引：一个索引只包括单个列，一个表中可以有多个单值索引
聚集索引：也就是主键索引，每个表中只要有主键那么该主键就自带聚集索引，若没有主键那么mysql会选择一个值不重复的列作为聚集索引，若不存在则它会建立一个隐藏的自增字段作为聚集索引
聚集索引和非聚集索引的区别？
聚集索引要求字段的值唯一，聚集索引在叶子节点存放的是表中所有的数据，非聚集索引在叶子节点存放的是主键id和索引列对应的数据
（非聚集索引不采用覆盖索引时要进行回表操作）

覆盖索引：指要查询的字段都属于一个索引中的字段，就称为覆盖索引，无需做回表操作，（回表：当要查询的字段大于索引的字段时，需要根据主键回表到主键索引中再查询二级索引中不包括的字段对应的值）

mysql5.7推出的索引下推
可以减少回表次数，它会先在索引表（二级索引）中对索引表中的字段进行判断，直接过滤掉不满足条件的记录，减少回表次数。
eg：select age,name,email from user where age=15 and name='郭'
现有索引(age,name)，那么执行查询时查询3个字段，2个在二级索引，1个在聚簇索引中
5.7之前它会根据最左匹配原则只判断第一个条件age，然后得到2个记录然后做两次回表，最后在server层做name='郭'的条件过滤得到最终结果
5.7之后它会在存储引擎获取数据时直接判断2个条件age，name，然后得到1个记录后做一次回表即可
所谓的索引下推简单来说就是：将之前在server层做的数据过滤下推到存储引擎层来直接做条件过滤，减少回表的次数

哪些列适合作为索引？
经常被查询，排序的列，数据量大，值大多都不重复的，外连接查询时On条件后面的字段
哪些情况不适合建立索引？
列中有很多重复的值，经常用于增删改的列，表记录太少，不要建立冗余索引（eg：建立了索引ab，就无需在建立索引a）

索引失效的原因：
一：未遵循最佳左前缀原则，where条件查询时，应该按照索引的顺序进行查询，不能缺少索引中的字段（缺少的字段后面的索引字段将失效），全职匹配我最爱
二：范围查找后失效(> < !=)，范围查找会导致索引失效，范围查找后面的条件会用不到索引
三：不在索引列上做操作，如在where条件后的字段做（函数，类型转换）会导致索引失效
四：like查询时%最好用在右边，否则会导致索引失效（除非采用覆盖索引（要查询的列和索引的列正好匹配））
五：is null 和is not null和or 会导致索引失效
六：尽量不要使用select *多使用覆盖索引，否则会造成回表操作（当用到我们自己创建的索引后，由于索引中存放的只有对应列的数据，select * 查询的是所有数据，因为还需要到主键索引中去获取对应的所有数据）
七：在使用左连接时，要为右边的表建立索引，在使用右连接时，要为左边的表建立索引
八：<，<=，=，>，>=，BETWEEN，IN 可用到索引，<>，not in ，!= 则不行，会导致全表扫描

为什么推荐使用整型自增主键而不是选择UUID？
UUID是字符串，比整形消耗更多的存储空间，导致存储的数据量就会变少
对索引来讲，在B+树中进行查找数据时需要比较值，整形比较的速度比字符串比较快
在插入数据时，因为UUID是随机的，容易破坏树的结构造成更多的性能浪费，对整形自增来说它会在叶子结点的末尾创建新的结点，不会破坏树的结构

sql优化：
①：当大批量插入数据时，可以采用foreach标签批量插入而不是在JAVA中使用for循环插入
②：优化limit分页，当查询的数据很靠后eg：limit：10000，10，可以采用：where id>10000 limit 10
③：删除冗余索引，eg：索引1（age） 索引2（age，name） 就可以删除掉索引1，因为索引2包括索引：（age）和（age，name）
④：where子句中考虑使用默认值代替null：where age is not null可以替换成where age >0

索引优化：
Explain+sql语句对sql进行分析，所显示的字段有
id（决定查询出来的多个表要执行的顺序）：id相同时：执行顺序从上至下，id不同时：id越大的越先执行
select_type（显示查询的类型）：simple：简单的sql查询 primary：最外层的查询 subquery：子查询 
table（显示该行数据属于哪张表）
type（显示该行数据所用的类型）：从好到坏 systetm>const>eq_Ref>ref>range>index>all 至少要达到range级别
possible_keys:显示可能用到的索引  key:实际用到的索引
key_len:索引用到的字节数
ref:哪些列用到了索引
rows：根据表的信息及索引的信息，估计出需要查找多少行可以找到对应的数据

慢查询日志
在开启慢查询日志后可以借助mysqlDrumpslow工具对慢查询日志进行分析。
SQL执行时间超过long_query_time将会被记录到慢查询日志当中，可以通过explain关键字对其进行分析

show profile（Explain的升级版）记录最近执行的15条sql

mysql的事务：ACID
原子性：事务内的操作要么都成功，要么都失败（mysql用undo log实现）
一致性：事务提交前和提交后，数据库的完整性约束没有被破坏
隔离性：多个事务间是相互隔离的互不影响
永久性：事务提交后，所修改的数据是永久生效的

redo log日志是InnoDB存储引擎的，它用来保证事务安全，在重启mysql时，根据redo log进行重做从而达到事务的永久性
undo log日志保存了事务提交之前的数据的一个版本，可以用于回滚，同时也提供多版本并发控制下的读

MVVC：多版本并发控制，行级锁的变种，在多线程操作数据库时保证事务隔离的机制，可以降低锁竞争的压力，保证较高的并发量
实现原理：Innodb中MVVC工作流程：通过在每行记录后保存两个隐藏的列来实现，一个保存了行的创建时间，一个保存了行的删除时间，这个时间不是真正的时间而是系统版本号，每开始一个新的事务都会
让版本号递增，事务开始时的版本号会作为事务的版本号，用来和查询到的每行的版本号进行比较。

事务的隔离级别（通过mysql锁的机制实现）
读未提交：读取到了还没有提交事务的数据
读已提交：读取到了已经提交的新增数据（可避免脏读）
可重复度：可以读到已提交的修改数据（可避免脏读，不可重复度）
可序列化（都可以避免）

事务并发带来的问题：
更新丢失：A和B同时更新，后面更新的数据会覆盖掉之前更新的数据
脏读：A读到了B未提交的数据
不可重复度：A读到了B已提交的修改数据
幻读：A读到了B已提交的新增数据

事务的传播机制：
Required：B方法在A方法中被调用，若A开启事务，则B就和A用同一事务
RequiresNew：B方法在A方法中被调用，若A开启事务，则B开启一个新事务，B和A的事务相互独立
Nested：B方法在A方法中被调用，若A开启事务，则B开启一个新事务，当A事务回滚则B事务也回滚，若B事务回滚A没事

主从复制：
将mysql进行主从复制，主库（master）负责写，从库（slave）负责读，实现读写分离和故障切换的高可用
原理：
主库将改变记录到二进制日志中（binary log）
从库读取主库的binary log 日志并拷贝到它的中继日志当中
从库重做中继日志中的事件，将改变应用到自己的数据库中，MYSQL的主从复制时异步串行化的
问题：延时，从库无法第一时间读取到主库新增的数据 解决方法：读取新增数据时，让他强制到主库中进行读取

三大范式
第一范式：数据库中的各个字段，都是不可分割的。（地区：中国山西，这个就可以分割为中国和山西）
第二范式：在满足第一范式的基础上，保证各个字段都是依赖于主键的。（若该字段离开主键照样可以知道值，也不算第二范式）
第三范式：在满足第二范式的基础上，各个字段不能有依赖关系（单价：10 数量：5 总价：50，这个总价就可以通过单价*数量算出来，就不符合第三范式了）

分表技术
分为水平分表和垂直分表（用数据库中间件技术mycat实现）
水平分表：当表中数据太多时，可按行分表（原来200行的表分为2个100行数据的表）
垂直分表：当表中字段太多时，可将一些不常用的字段分离到新的表上，通过外键关联（5个字段的表，分为一个4个字段一个1个字段的表）

Mysql中的锁：
一：读锁（共享锁）和写锁（排它锁）：
读锁：针对同一份数据，多个读操作可以同时执行，互不影响
写锁：针对同一份数据，当执行写操作时，其他线程是无法进行读操作和写操作
eg：添加写锁的方式：select quantity from items where id=100 for update;(为id为100的数据添加写锁)，直到对id为100的数据操作完毕，锁会自动释放
二：行锁，表锁，页锁：
行锁：开销大，加锁慢，会出现死锁，锁的粒度最小，并发高，InnoDb支持行锁和表锁，默认是行锁（InnoDB的行锁依赖于索引，一旦某个加锁操作用不到索引，就会退化为表锁）
表锁：开销小，加锁块，不会出现死锁，锁的粒度大，并发低，MyIsam和Memory是行锁
页锁：介于两者之间，会出现死锁。

*唯一索引普通索引选择难题
唯一索引无法使用changebuffer，普通索引可以使用
执行更新操作，判断数据页是否在内存，在内存直接更新，不在内存则将其缓存到changebuffer执行merge操作

一个很长的字段，想做索引我们怎么去优化它
因为字段很长，所以要建立B+树索引的话，索引所占的磁盘空间就越大，搜索效率就不高
可以使用hash索引，把字段hash为另一个字段存起来，每次校验hash就可以了	

select *和 select 全部字段的区别
select *要解析数据字典，select 全部字段不需要
select 全部字段更具有可读性
select全部字段 可以按指定字段顺序输出，select *按照建表顺序输出

having和where的区别
having是在分组group by时使用
having在where后执行
having无法用到索引，where可以
having可以用到聚集函数，where不可以

PreparedStatment和Statment区别
statment会频繁编译sql
PreparedStatment可以对sql预编译，提高效率
当sql中有条件时，PreparedStatment可以使用占位符，statment则需要进行拼接，因此statment有SQL注入问题

当要删除百万级别的数据库中的数据时怎么删除？
如果直接删除数据的话，性能不高，因为它还需要改变索引中的数据
可以先删除索引，再删除要删除的数据，然后再创建索引。（这样比之前直接删除数据的效率快很多）

数据库连接池：
因为每次获取和释放连接都很耗时，因此有了数据库连接池，在项目启动时就建立一定数量的池连接，获取连接时从池中获取，释放连接时，
不是将连接直接释放掉，而是将连接再归还到连接池当中。（底层通过list集合来对连接进行存放）
当有连接请求到连接池，如果有连接处于空闲状态则直接返回一个空闲连接并标记为忙。
		     如果当前没有空闲连接，就会新建一定数量的连接，新建连接的数量由配置参数决定

mysql中的日志：
binlog日志，中继日志（主从同步用），undolog日志（回滚用），redolog日志（持久化日志），慢查询日志（记录慢sql），错误日志 