jdk是JAVA开发工具包，包含了各种JAVA类库
JRE是JAVA运行时环境通过它才能将开发的程序发布到用户手中
JVM是JAVA虚拟机（JVM是个标准，它的实现有HotSpot虚拟机）所有程序编译为.class文件后在虚拟机上运行
JDK包括JRE,JRE包括JVM
jvm的作用：将.class字节码文件生成操作系统指令，传递给操作系统后通过计算机运行

并行和并发的区别：
并发是指一个时间段内有两个及以上的程序执行
并行是指一个时刻内有两个及以上的程序执行

java跨平台：
windows平台使用的是Intel汇编，unix平台使用的是AT&T汇编，还有一种汇编是ARM，各个平台的底层汇编都不一样，因此很多语言，一段相同的代码无法在多个平台运行
JAVA中一段相同的代码，在不同的系统上使用其系统对应的JVM来运行，那么运行结果是相同的

jvm即JAVA虚拟机
年轻代对象经过15次GC后依然存活的话就放入老年代
jvm的堆内存模型：jdk1.7：年轻代，老年代，永久区 jdk1.8：eden，s0，s1，老年代，元空间（虚拟机中加载的类信息，即时编译后的代码，常量池，静态变量），由于永久代经常发生内存泄漏所以替换为元空间
年轻代占堆大小的1/3，老年代占堆大小的2/3,eden占年轻代的4/5，s0，s1各占年轻代的1/10

java的内存模型：read，load，use，assign，store，write，lock，unlock

jvm的内存区域（运行时数据区）：线程共享的有堆，方法区，线程独占的有虚拟机栈，本地方法栈，程序计数器

堆：各种对象实例和数组都在堆中分配内存，分为年轻代，老年代

虚拟机栈：虚拟机栈包括多个栈帧，类中各个方法对应栈中的一个栈帧，每个栈帧中包括方法中的局部变量（基本类型存放的是值，引用类型存放的是实际堆内存的地址），方法的出口，
	动态链接（符号引用在运行期间转化为直接引用,这种转化为动态链接），操作数栈（存放计算过程中的中间结果）
	（栈就是后进先出，因此被嵌套执行的方法（后运行的方法）先结束，再结束外面的方法）

堆和虚拟机栈的关系：当有一个引用类型的局部变量时，它新建后存放在堆当中，栈中存放的是该引用变量的引用（指针）
		  栈中存放的变量生命周期一旦结束就会被销毁，堆中存放的对象会被垃圾收集器不定时收集
		  栈的内存地址是连续的，堆的内存地址是不连续的 
本地方发栈：用于调用本地方法的，程序运行中可能会调用到一些用C/C++编写的native对象，调用到之后就将其放在本地方法栈里面

程序计数器：用于记录当前线程在栈中程序执行到哪一步（以便于线程上下文切换后能找到正确的执行位置）
					    上下文切换：CPU为线程分配一个时间片，时间片结束会重新进入就绪状态，让其他线程执行，以此来保证每个线程都能运行到
方法区（元空间）：存放：即时编译后的代码（class文件），常量池，静态变量，虚拟机中加载的类的信息 （大小可以设为物理内存的 1/32）
（替换掉了1.7的永久代，因为永久代是存放在堆内存中的，经常会发生内存不够用和内存泄漏的情况，元空间所占用的空间是在本机的内存中不在堆内存中） 

双亲委派机制：当一个类加载器要加载一个类时，判断该类是否被加载过（加载过直接返回）然后将该类交给其父加载器去完成，每一次都是如此，直到递归到最顶层，只有父加载器无法完成这个请求时，
	       才会自顶向下交给子类去加载。
	作用：防止重复加载同一个.class，保证.class的执行安全，保证核心的.class不能被篡改
						   （自顶向下加载，首先加载核心的.class，最后才会加载自己写的类，保证核心的不被篡改，eg:自己写一个String类，系统只会加载lang包下的）

类加载子系统：  （自顶向下）
	         引导类加载子系统：最顶层的类加载器（父类加载器）加载JAVA的一些核心类和jar包
	         扩展类加载子系统：加载JRE下的jar包
	         应用类加载子系统：加载当前classPath下的字节码文件，主要加载自己写的那些类

如果我们不想使用双亲委派原则，则可以自定义一个类加载器继承ClassLoader，重写loadClass（）方法（该方法就是启动双亲委派的方法）
类加载如何保证线程安全？类加载时调用的loadClass方法是被synchronized所修饰的。

同一个JVM中，两个相同包名和类名的类对象可以共存，前提是他们的类加载器不一样。所以看两个对象是否相同，除了看包名和类名之外，还需要看他们的类加载器是否相同

JVM加载class文件的原理机制：JAVA中所有类的加载都是由类加载器实现的，类加载器再装载到JVM中去运行。

类加载器（类的加载过程）的执行过程：
加载：在硬盘上查找并通过IO读入字节码文件至JVM虚拟机方法中，同时在堆中创建Class对象
验证：校验字节码文件的正确性
准备：为类中静态变量分配内存，并将其初始化为默认值（int->0,boolean->false），此阶段只会为被static修饰的变量分配内存并初始化，对于被static final修饰的变量在编译期间就已经分配内存初始化了。
解析：把类中的符号引用转换成直接引用
初始化：对类中的静态成员变量进行初始化，执行静态代码块。（在新建类的时候才会对普通成员变量和普通代码块进行初始化）

如何判断一个对象是垃圾对象：
引用计数法：被引用到的对象，计数器会+1，计数器为0时，会认为该对象是垃圾对象被回收掉（由于无法解决循环引用问题，已被淘汰）
可达性分析法：未被根结点引用的对象就是垃圾对象。

哪些对象可以作为根结点对象？
本地方法栈中(native)引用到的对象
虚拟机栈中引用到的对象
方法区中常量引用的对象
方法区中类静态属性引用到的对象

GC的类型：
总体分为两大类：PartialGC(部分收集)和FullGC(整堆收集)
PartialGC中包括：YoungGC/MinorGC：单单收集年轻代的GC
	            OldGC/MajorGC：单单收集老年代的GC
	            MixedGC：这个是G1独有的，指的是收集整个年轻代和部分老年代

jvm中的垃圾回收（GC）算法：
标记清除算法：分为两步，第一步为标记将被根结点引用到的对象进行标记，第二步清除将未被标记到的对象给清除掉。问题：效率低，每次标记对象时会进行STW，内存碎片化严重（老年代）
标记压缩算法：相较于标记清除算法，他在清除前会将标记好的对象压缩到一起，然后进行清除，他解决了内存碎片化严重的问题，效率不高因为它还需要一个压缩的步骤（老年代）
复制算法：分为form和to两个区域，当进行垃圾回收时，将form区非垃圾对象移到to区，在移动的过程中将垃圾清除掉，然后to和form区调换位置，保证to区为空（年轻代，因为年轻代的对象只有少数会存活下来
所以使用复制算法效率是最高的）但浪费空间需要一块空间来移动数据（年轻代）
分代算法：根据不同的代选择不同的算法

标记清除：每次都会STW且内存碎片化严重，标记压缩：效率不高，复制算法：浪费空间

jvm中的垃圾收集器：
串行垃圾收集器：它在进行GC垃圾回收时，会STW阻止用户线程的执行。（年轻代：复制，老年代：标记压缩）
并行垃圾收集器：它在进行GC垃圾回收时会启动多个垃圾回收的线程并行回收，但他也会STW阻塞用户线程的执行。（年轻代：复制，老年代：标记压缩）
cms垃圾收集器：它在进行GC垃圾回收时可以让垃圾回收的线程和用户线程并行执行，它采用的是标记清除算法。（年轻代：复制，老年代：标记清除）
G1垃圾收集器: 它取消了年轻代和老年代的划分，取而代之的是将整个堆内存划分为了若干区域（eden，survivor，old，humongous（专门用来存放巨型对象的超过50%计算））它在GC时采用的是类似于复制算
法的方式，解决了CMS的碎片化问题，且它可以指定GC的时间（大部分采用标记压缩，有时采用复制）

G1和CMS的比较
CMS：
CMS分为：初始标记，并发标记，重新标记，并发清除
初始标记：仅仅标记能被Root对象直接引用到的对象
并发标记：标记整个堆中被Root对象引用到的对象
重新标记：对于一些不确定是否是垃圾的对象会进行重新标记
并发清除：清除掉垃圾对象
①：CMS收集器是获取最短回收停顿时间为目标的收集器，因为CMS工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的（只有初始标记和重新标记会STW）。但是CMS收集器
对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致程序变慢，总吞吐量下降。
②：CMS仅作用于老年代，是基于标记清除算法，所以清理的过程中会有大量的空间碎片。
③：CMS收集器无法处理浮动垃圾，浮动垃圾：（由于CMS并发清理阶段用户线程还在运行，伴随程序的运行自然会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只
好留待下一次GC时将其清理掉）。***当浮动垃圾太多会让CMS变成串行CMS

G1：
④：G1是一款面向服务端应用的垃圾收集器，适用于多核处理器、大内存容量的服务端系统。G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短STW的停顿时间，它满足短
时间停顿的同时达到一个高的吞吐量。
⑤：从JDK 9开始，G1成为默认的垃圾回收器。当应用有以下任何一种特性时非常适合用G1：Full GC持续时间太长或者太频繁；对象的创建速率和存活率变动很大；应用不希望停顿时间长(长于0.5s甚至1s)。
⑥：G1将空间划分成很多区（Region），eden，survivor，old，Humongous区（Humongous专门用于巨型对象，当对象占用空间超过了分区的50%就是巨型对象了）
然后他们各自进行回收。堆比较大的时候可以采用，采用复制算法，碎片化问题不严重。整体上看属于标记整理算法,局部(region之间)属于复制算法。
⑦：G1 需要记忆集 (具体来说是卡表)来记录新生代和老年代之间的引用关系，这种数据结构在 G1 中需要占用大量的内存，可能达到整个堆内存容量的 20% 甚至更多。而且 G1 中维护记忆集的成本较高，带来了
更高的执行负载，影响效率。
所以 CMS 在小内存应用上的表现要优于 G1，而大内存应用上 G1 更有优势，大小内存的界限是6GB到8GB。

G1缺点：耗费空间耗费内存，to和form复制来复制去的
CMS缺点：耗费CPU资源，且会有内存碎片，无法处理掉浮动垃圾
G1和CMS都属于并发垃圾收集器：在垃圾收集时可以让GC垃圾收集线程和用户线程同时执行。

如果是jdk14以前，则可以选用ParNew+CMS或者G1;jdk14后，选择G1；

为什么说CMS垃圾收集器是一款低延时垃圾收集器？
因为CMS垃圾收集器只有在初始标记和重新标记的时候会STW，在并发标记和并发清除的时候并不会STW并且它支持GC线程和用户线程同时执行。

为什么CMS垃圾收集器不使用标记整理算法来解决内存碎片化？
因为CMS垃圾收集器在并发标记和并发清除的时候用户线程和GC线程同时执行，而标记整理算法中存在对象在内存中的定向移动，因此如果用户线程发生了移动就会造成线程安全问题

jvm中常见的参数：
-xx:xms:初始堆大小：默认占电脑内存的1/64
-xx:xmx:最大堆大小：默认占电脑内存的1/4
-xx:xmn:年轻代大小
-xx:xss:栈大小
-xx:+printGCDetails:打印出GC的详情
-xx:metespaceSize:元空间大小

如何查看JVM中的参数？
-xx:+printflagsInitial:打印出jvm的初始参数
①-xx:+printflagsfinal:  ②jps -l或者ps -ef|grep java 打印出程序的pid  jinfo -flags pid : 打印出jvm当前设置的参数
-xx:+printcommandLineFlags:打印出jvm所用的垃圾收集器

如何进行JVM调优？（减少full gc的次数）
一：先查看服务器的性能：通过top或uptime查看整机的性能
二：查看程序中堆内存的信息：jmap命令将内存信息dump出来（jmap -dump:fromat=b file=文件存放的路径 <pid>）通过mat工具进行分析查看（或者直接用jdk自带的jvisualvm工具进行查看）是否有内存泄漏的情况，
如果存在内存泄漏的话可以通过工具进一步查看Roots的引用链来查找到对应的问题代码
三：查看JVM的参数信息：通过jInfo命令查看或直接打印出JVM的参数信息-xx+:printflagsInitial，查看JVM中垃圾收集器-xx+:printCommandlineflags,查看JVM最终参数-xx:+printflgsFinal
四：对JVM的GC情况做检查：通过-xx+printGCDetails打印出GC.log日志，用在线工具（https://gceasy.io）对其进行查看，查看fullGC的次数，若太多的话根据具体的业务情况可通过-xx：xmn来设置年轻代的大小来减少fullGc，也可以
设置一些其他的参数信息。
五：查看线程的使用情况通过jstack命令来查看线程使用是否存在死锁。

线上JVM调优：
调优的目的：让用户体验更好，减少fullGC的次数，因为fullGC的时候会STW，STW时用户线程无法执行
一：FullGC太频繁（当老年区满了或者方法区满了会触发FullGC）
初始堆大小设定是3G，年轻代占1/3 1G，eden区占年轻代的8/10 800M，两个survivor区各占1/10 100M
代码中有个接口每次调用都会创建一个60M大小的对象，当eden区满了进行minorGC的时候，又创建了一个60M的对象（浮动对象），此时直接就放入survivor区了，由于它的大小大于survivor区的1/2
所以直接被存放到了老年代，以此递推最终老年代会被放满发生fullGc，因此可以将年轻代大小设置大一些，这样浮动对象就不会放到老年代，可以完美减少FullGc次数

二：元空间情况（元空间如果不指定大小，他会随着类的不断创建，虚拟机会耗尽所有可用的系统内存）
服务进程占用了容器的物理内存（16G）的百分之80
通过jmp命令将内存的使用情况jump出来（jmp jump：format-b file=要存放的位置 <pid>）后用mat工具进行分析发现是元空间占用内存太大了
查看配置的启动参数的时候，发现对永久代的大小作了限制（-XX:PermSize=256m -XX:MaxPermSize=512m），最后发现线上用的是1.8的环境，1.8当中永久代被元空间代替了
所以删除了永久代的配置，添加了元空间的配置（-XX:MetaspaceSize=64m -XX:MaxMetaspaceSize=128m）最终问题得到了解决

讲讲什么情况下会出现内存溢出，内存泄漏？
内存泄漏：JAVA是自动进行垃圾回收的，可能会出现已过期的对象，JVM还误以为此对象没过期，没有回收，最终造成内存泄漏。
	造成内存泄漏的方式：集合（集合中添加了对象，对象已经用不到了，但集合对对象还存在着引用导致无法被回收出现了内存泄漏），各种连接没有关闭（数据库，io，线程池）
内存溢出：内存不够用了，可能是由于内存泄漏，死循环，设定的内存太小，对象太大导致。

三：JVM工作步骤
新产生的对象存放到eden区当中，eden区满了进行MinorGC，存活的对象会存放到survivor0区，MinorGC时会通过复制算法，将S0区的存活对象复制到S1区当中，最后S1再和S0区交换位置
每经历一次MinorGC，存活下来的对象分代年龄都会+1，当分代年龄达到15的时候，就将其放入老年代，老年代占满了就会发生FullGC（大部分FullGC采用标记整理算法，CMS采用标记清除）。

为什么要分老年代年轻代？
因为对象创建出来，它的存活时间是不一样的，有很多的对象生命周期很短暂这些对象就存放到年轻代，老年代存放的对象都是经过很多次GC后还存活的对象，这样做主要为了优化GC性能，如果不分年轻代老年代
每次GC的时候都要遍历所有的对象，会造成较长的STW的时间，影响用户的体验，分代也算是对对象的一种管理方式。

什么情况下回触发FullGc？
当手动调用System.gc()时，当元空间满了时，当老年代满了时

如何判断一个常量是废弃常量？
假如常量池中存在字符串“abc”，若“abc”没有被任何String对象引用，那么常量“abc”就是废弃常量

如何判断一个类是无用的类?
①：类中所有属性已被回收
②：该类的classLoader已被回收
③：该类的Class对象没有被引用

一个Object对象在内存中占多少字节？
占16个字节，对象头占8个字节，类型指针占4个字节，此时总共12个字节但JVM虚拟机要求对象大小为8的整数倍，于是用对齐填充将其填充为16

堆是分配对象的唯一选择吗？
随着jdk的不断升级，现在也可以在栈上存放对象，前提条件就是对象在方法中new出来只在方法内部使用且它没有被外界所引用，如果被外界所引用的话该对象还是会存放到堆中

对象怎么分配？
先去栈中尝试分配对象，然后去堆中eden区的TLAB(Thread Local Allocation Buffer，线程本地缓冲区)中尝试分配对象，如果都分配不成功最后则会去堆中分配对象。
TLAB:线程本地缓冲区，它属于eden区，只占eden区大小的百分之1，它作为jvm内存分配的首选（因为堆空间是线程共享的，如果多个对象同时操作堆中同一对象会有线程安全问题，虽然可以采用加锁解决但是
会影响性能，因此我们可以通过TLAB来解决，存放在堆中TLAB中的对象是线程安全的）
PLAB:和TLAB很像，它是用于年轻代对象晋升到老年代时

对象的访问定位（JVM是如何通过虚拟机栈中的栈帧中的局部变量表中的地址来访问到对象的实例数据的呢）
直接指针(hotspot虚拟机采用)：通过栈帧中的局部变量表中的引用地址值找到位于堆空间的对象的实例数据。

对象的引用类型：
strong Reference：强引用，我们一般new的对象都是强引用的，无论内存是否已满,GC是无法回收掉强引用的对象，除非将对象置为null
soft Reference：软引用：对于软引用对象来说，当内存满了GC会回收软引用对象，如果内存不满则不会回收软引用对象
weak Reference：弱引用：对于弱引用对象来说，无论内存是否已满，GC都会回收掉弱引用的对象
虚引用：可以跟踪对象的垃圾回收过程